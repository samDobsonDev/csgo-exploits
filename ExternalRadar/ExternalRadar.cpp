#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

#define dwEntityList 0x4DA2F54
#define m_bSpotted 0x93D

HANDLE processHandle;
DWORD moduleBaseAddress;

DWORD GetProcessID(const char* processName) //sets GetProcesID function, takes "csgo.exe" as a parameter
{
    DWORD processID = 0;

    PROCESSENTRY32 processesArray{ 0 }; //creates array
    processesArray.dwSize = sizeof(processesArray); //sets size of structure

    HANDLE findProcessID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //creates snapshot of all current processes ...
    BOOL processEnum = Process32First(findProcessID, &processesArray); //gets first result and places it in the array
    while (processEnum)
    {
        if (strcmp(processName, processesArray.szExeFile) == 0) //if processName and the current process being enumerated have the same name...
        {
            processID = processesArray.th32ProcessID; //set new variable processID to the ID of the current process being enumerated
            std::cout << (processID) << std::endl;
            break;
        }
        processEnum = Process32Next(findProcessID, &processesArray); //gets next result and places it in the array
    }
    CloseHandle(findProcessID); //closes handle
    return processID; //returns process ID
}

uintptr_t GetModuleBaseAddress(DWORD processModuleID, const char* moduleName) { //gets module base address for client.dll
    HANDLE findModuleAddress = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, processModuleID); //creates snapshot of all running 64-bit/32-bit modules in the specified process
    if (findModuleAddress != INVALID_HANDLE_VALUE) { //while handle is OK and moduleEnum....
        MODULEENTRY32 modulesArray{ 0 };
        modulesArray.dwSize = sizeof(modulesArray);
        if (Module32First(findModuleAddress, &modulesArray)) { //gets first result and places it in the array
            do {
                if (strcmp(moduleName, modulesArray.szModule) == 0) { //if moduleName and the current module being enumerated match...
                    CloseHandle(findModuleAddress); //close handle
                    std::cout << (modulesArray.szModule) << std::endl;
                    return (uintptr_t)modulesArray.modBaseAddr; //returns module address
                }
            } while (Module32Next(findModuleAddress, &modulesArray)); //otherwise go to next module and check again 
        }
    }
}

template<typename T> T RPM(SIZE_T address) {
    T buffer; ReadProcessMemory(processHandle, (void*)address, &buffer, sizeof(T), nullptr);
    return buffer;
}

template<typename T> void WPM(SIZE_T address, T buffer) {
    WriteProcessMemory(processHandle, (void*)address, &buffer, sizeof(T), nullptr);
}

int main()
{
    const char* processName = "csgo.exe";
    moduleBaseAddress = GetModuleBaseAddress(GetProcessID(processName), "client.dll"); //creates moduleBaseAddress variable, which calls to GetModuleBaseAddress function, which takes the Process ID and the module name as parameters
    std::cout << &moduleBaseAddress;
    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessID(processName));

    while (true)
    {
        for (int i = 1; i < 64; i++) { //max 64 players in a cs game
            DWORD dwCurrentEntity = RPM<DWORD>(moduleBaseAddress + dwEntityList + i * 0x10);
            if (dwCurrentEntity) {
                WPM<bool>(dwCurrentEntity + m_bSpotted, true);
            }
        }
        Sleep(50);
    } return 0;
}
