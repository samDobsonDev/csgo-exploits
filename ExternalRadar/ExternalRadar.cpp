#include <iostream>
#include <Windows.h>
#include <TlHelp32.h>

#define dwEntityList 0x4DA3F44
#define m_bSpotted 0x93D

DWORD moduleBaseAddress;
HANDLE processHandle;

DWORD GetProcessID(const char *processName) //sets GetProcesID function, takes "csgo.exe" as a parameter
{
    DWORD processID = 0;

    PROCESSENTRY32 processesArray{ 0 }; //creates array
    processesArray.dwSize = sizeof(processesArray); //sets size of structure

    HANDLE findProcessID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //creates snapshot of all current processes ...
    BOOL processEnum = Process32First(findProcessID, &processesArray); //gets first result and places it in the array
    while (processEnum)
    {
        if (strcmp(processName, processesArray.szExeFile) == 0) //if processName and the current process being enumerated have the same name...
        {
            processID = processesArray.th32ProcessID; //set new variable processID to the ID of the current process being enumerated
            break;
        }
        processEnum = Process32Next(findProcessID, &processesArray); //gets next result and places it in the array
    }
    CloseHandle(findProcessID); //closes handle
    return processID; //returns process ID
}

uintptr_t GetModuleBaseAddress(DWORD processModuleID, const char *moduleName) //gets module base address for client.dll
{   
    MODULEENTRY32 modulesArray{ 0 }; //creates array
    modulesArray.dwSize = sizeof(modulesArray); //sets size of structure

    HANDLE findModuleAddress = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE | TH32CS_SNAPMODULE32, processModuleID); //creates snapshot of all running 64-bit/32-bit modules in the specified process
    BOOL moduleEnum = Module32First(findModuleAddress, &modulesArray); //gets first result and places it in the array
    while (findModuleAddress != INVALID_HANDLE_VALUE) //while handle is OK
    {
        if (strcmp(moduleName, modulesArray.szModule) == 0) //if moduleName and the current module being enumerated match...
        {
            CloseHandle(findModuleAddress); //close handle
            return (uintptr_t)modulesArray.modBaseAddr; //return module address currently being enumerated
        }
        moduleEnum = Module32Next(findModuleAddress, &modulesArray); //otherwise go to next module and check again 
    }
}

template<typename RPM> 
    RPM readProcessMemoryTemplate(DWORD address) //Call to this template on line 77 sets RPM to DWORD data type
    {
    RPM buffer; //creates buffer of type DWORD
    ReadProcessMemory(processHandle, (LPVOID)address, &buffer, sizeof(RPM), NULL);
    return buffer; //returns what has been placed in the buffer
    }

template<typename WPM> 
    void writeProcessMemoryTemplate(DWORD address, WPM buffer) //Call to this template on line 79 sets WPM to bool data type
    {
    WriteProcessMemory(processHandle, (LPVOID)address, &buffer, sizeof(WPM), NULL);
    }

int main()
{
    AllocConsole(); //creates console
    const char *processName = "csgo.exe";
    moduleBaseAddress = GetModuleBaseAddress(GetProcessID(processName), "client.dll"); //creates moduleBaseAddress variable, which calls to GetModuleBaseAddress function, which takes the Process ID and the module name as parameters
    std::cout << "Module Address Found for client.dll: " << &moduleBaseAddress << std::endl; //print client.dll address
    processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, GetProcessID(processName));

    if (processHandle) //if we have a handle...
    {
        std::cout << "Handle to Target Process Acquired..." << std::endl;
        std::cout << "Adding Entities to Radar..." << std::endl;
        while (true)
        {
            for (int i = 1; i < 64; i++) { //for each player in the game...
                //get the player...
                DWORD dwCurrentEntity = readProcessMemoryTemplate<DWORD>(moduleBaseAddress + dwEntityList + i * 0x10); //calls RPM template, specifying type as DWORD. This gets current player - 0x10 is the gap between players
                if (dwCurrentEntity) {
                    //add the player to the radar
                    writeProcessMemoryTemplate<bool>(dwCurrentEntity + m_bSpotted, true); //calls WPM template, specifying type as bool. This draws the current player to the minimap by changing m_bSpotted to true
                }
            }
            Sleep(0);
        }
    }
    return 0;
}
