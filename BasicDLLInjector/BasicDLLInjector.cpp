#include <Windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <string.h>

int main()
{
    AllocConsole();
    std::cout << "Basic DLL Injector - created by Sam Dobson\n\n";

    const char *dllPath = "D:\\Code\\csgo-exploits\\ExtrasensoryPerceptionDLL\\Release\\ExtrasensoryPerceptionDLL.dll"; //at the memory address for dllPath, the following character sequence is stored
    const char *processName = "csgo.exe"; //at the memory address for processName, the following character sequence is stored
    
    DWORD processID = 0;

    PROCESSENTRY32 processArray{ 0 }; //creates array
    processArray.dwSize = sizeof(processArray); //sets size of structure

    HANDLE findProcessID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //creates snapshot of all current processes ...
    BOOL processEnum = Process32First(findProcessID, &processArray); //gets first result and places it in the array
    while (processEnum)
    {
        if (strcmp(processName, processArray.szExeFile) == 0) //if processName and the current process being enumerated have the same name...
        {
            processID = processArray.th32ProcessID; //set processID to the ID of the current process being enumerated
            break;
        }
        processEnum = Process32Next(findProcessID, &processArray); //gets next result and places it in the array
    }

    CloseHandle(findProcessID);

    if (processID == 0)
    {
        std::cout << "Process ID could not be found - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "The process ID of target process is: " << (processID) << std::endl;
    }

    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    if (!processHandle)
    {
        std::cout << "\nFailed to gain a handle to the process - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nHandle to target process acquired..." << std::endl;
    }

    void *memoryAddress = VirtualAllocEx(processHandle, NULL, strlen(dllPath) + 1, MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE); //is a pointer because WriteProcessMemory needs a pointer as the parameter
    if (!memoryAddress)
    {
        std::cout << "Memory space could not be allocated - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nMemory space allocated..." << std::endl;
    }

    bool memoryWrite = WriteProcessMemory(processHandle, memoryAddress, dllPath, strlen(dllPath) + 1, NULL);
    if (!memoryWrite)
    {
        std::cout << "Memory space could not be written to - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nMemory space written to..." << std::endl;
    }

    HANDLE memoryWriteHandle = CreateRemoteThread(processHandle, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, memoryAddress, NULL, NULL);
    if (!memoryWriteHandle)
    {
        std::cout << "DLL could not be injected - Error code: " << GetLastError() << std::endl;
        return false;
    }

    CloseHandle(memoryWriteHandle);
    CloseHandle(processHandle);

    std::cout << "\nInjection successful!\n\n";
    return 0;
}