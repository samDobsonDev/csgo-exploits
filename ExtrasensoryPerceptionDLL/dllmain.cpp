#include <iostream>
#include <Windows.h>

#define dwLocalPlayer 0xD8C2CC
#define dwGlowObjectManager 0x52EC558
#define dwEntityList 0x4DA3F44
#define m_iTeamNum 0xF4
#define m_iGlowIndex 0xA438

DWORD moduleHandle;
DWORD localPlayer;
DWORD glowObjectManager;
DWORD entityList;
DWORD currentEntity;
int localTeam;
int glowIndex;
int entityTeam;

float glowFriendlyRed = 0.f;
float glowFriendlyGreen = 1.f;
float glowFriendlyBlue = 0.f;

float glowEnemyRed = 1.f;
float glowEnemyGreen = 0.f;
float glowEnemyBlue = 0.f;

float glowAlpha = 1.f;
bool glowNotOcclude = true;
bool glowOcclude = false;

DWORD WINAPI Exploit(HMODULE hModule)
{
    AllocConsole(); //creates console
    FILE *tempFile = NULL; //creates null variable of type FILE
    freopen_s(&tempFile, "CONOUT$", "w", stdout); //freopen_s: Closes the file currently associated with oldStream and reassigns stream to the file specified by fileName

    std::cout << "Extrasensory Perception DLL - created by Sam Dobson\n\n";
    DWORD moduleHandle = (DWORD)GetModuleHandle("client.dll"); //reteives handle to client.dll

    while (moduleHandle) //while we have a mandle to the client.dll module...
    {
        DWORD localPlayer = *(DWORD*)(moduleHandle + dwLocalPlayer); //retreives local player
        DWORD glowObjectManager = *(DWORD*)(moduleHandle + dwGlowObjectManager); //retreives glow object manager
        DWORD entityList = *(DWORD*)(moduleHandle + dwEntityList); //retreives list of every player in the game
        int localTeam = *(int*)(localPlayer + m_iTeamNum); //gets the team number of the local player
        std::cout << "Local Player Team Number: " << localTeam << std::endl;
        Sleep(10);

        for (int i = 1; i < 16; i++) //repeat for every player in the game...
        {
            DWORD currentEntity = *(DWORD*)(moduleHandle + dwEntityList + i * 0x10); //for each player in the game
            if (currentEntity == NULL) continue;

            int glowIndex = *(int*)(currentEntity + m_iGlowIndex); //add the player to the glow index
            
            int entityTeam = *(int*)(currentEntity + m_iTeamNum); //look what team they are on
            std::cout << "Match Entity Team Number: " << entityTeam << std::endl;
            Sleep(10);
            if (entityTeam == localTeam) //if the team of the currently enumerated player is the same as the local player AKA. friendly...
            {
                //0x38 = colour offset. Each colour is at an offset interval of 4 bytes e.g 4, 8, C, 10 (hex). 0x24 is the glowNotOcclude value (enabling glow), 0x25 is the glowOcclude value (disabling glow)
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x4) = glowFriendlyRed; //glow red
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x8) = glowFriendlyGreen; //glow green
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0xC) = glowFriendlyBlue; //glow blue
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x10) = glowAlpha; //opacity
            }
            else //if the team of the currently enumerated player is NOT the same as the local player AKA. enemy...
            {
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x4) = glowEnemyRed; //glow red
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x8) = glowEnemyGreen; //glow green
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0xC) = glowEnemyBlue; //glow blue
                *(float*)(glowObjectManager + glowIndex * 0x38 + 0x10) = glowAlpha; //opacity
            }
            *(bool*)(glowObjectManager + glowIndex * 0x38 + 0x24) = glowNotOcclude; //glowNotOcclude offset
            *(bool*)(glowObjectManager + glowIndex * 0x38 + 0x25) = glowOcclude; //glowOcclude offset
        }
    }
    FreeLibraryAndExitThread(hModule, 0);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)Exploit, hModule, NULL, NULL);
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}