#include <iostream>
#include <Windows.h>

#define dwLocalPlayer 0xD8B2CC
#define dwGlowObjectManager 0x52EB548
#define dwEntityList 0x4DA2F54
#define m_iTeamNum 0xF4
#define m_iGlowIndex 0xA438

DWORD moduleHandle;
DWORD localPlayer;
DWORD glowObjectManager;
DWORD entityList;
DWORD currentEntity;
int localTeam;
int glowIndex;
int entityTeam;

float GlowEnemyRed = 1.f;
float GlowEnemytGreen = 0.f;
float GlowEnemyBlue = 0.f;
float GlowEnemyAlpha = 1.f;

float GlowFriendlyRed = 0.f;
float GlowFriendlyGreen = 1.f;
float GlowFriendlyBlue = 0.f;
float GlowFriendlyAlpha = 1.f;

DWORD WINAPI dll(HMODULE hModule)
{
    DWORD moduleHandle = (DWORD)GetModuleHandle("client.dll"); //reteives handle to client.dll

    while (!GetAsyncKeyState(VK_END)) //while the end key is not being pressed...
    {
        DWORD localPlayer = *(DWORD*)(moduleHandle + dwLocalPlayer); //retreives local player
        DWORD glowObjectManager = *(DWORD*)(moduleHandle + dwGlowObjectManager); //retreives glow object manager
        DWORD entityList = *(DWORD*)(moduleHandle + dwEntityList); //retreives list of every player in the game
        int localTeam = *(int*)(localPlayer + m_iTeamNum); //gets the team number of the local player

        for (int i = 1; i < 64; i++) //repeat for every player in the game)...
        {
            DWORD currentEntity = *(DWORD*)(moduleHandle + dwEntityList + i * 0x10); //for each player in the game
            if (currentEntity == NULL) continue;

            int glowIndex = *(int*)(currentEntity + m_iGlowIndex); //add the player to the glow index
            
            int entityTeam = *(int*)(currentEntity + m_iTeamNum); //look what team they are on
            if (entityTeam == localTeam) //if the team of the currently enumerated player is the same as the local player AKA. friendly...
            {
                //0x38 = colour offset
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x4)) = GlowFriendlyRed; //glow red
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x8)) = GlowFriendlyGreen; //glow green
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0xC)) = GlowFriendlyBlue; //glow blue
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x10)) = GlowFriendlyAlpha; //opacity
                *(bool*)((glowObjectManager + glowIndex * 0x38 + 0x24)) = true; //turns the glow on
            }
            else //if the team of the currently enumerated player is NOT the same as the local player AKA. enemy...
            {
                //0x38 = colour offset
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x4)) = GlowEnemyRed; //glow red
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x8)) = GlowEnemytGreen; //glow green
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0xC)) = GlowEnemyBlue; //glow blue
                *(float*)((glowObjectManager + glowIndex * 0x38 + 0x10)) = GlowFriendlyAlpha; //opacity
                *(bool*)((glowObjectManager + glowIndex * 0x38 + 0x24)) = true; //turns the glow on
            }
        }
    }
    FreeLibraryAndExitThread(hModule, 0);
    return 0;
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        CloseHandle(CreateThread(nullptr, 0, (LPTHREAD_START_ROUTINE)dll, hModule, 0, nullptr));
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}