#include <Windows.h> //DWORD
#include <iostream> //User input/output
#include <string>
#include <psapi.h> //EnumProcessModules
#include <VersionHelpers.h> //For Windows Version
#include <atlstr.h> // CString

#define CREATE_THREAD_ACCESS (PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ) // desired access flags for OpenProcess

BOOL InjectDLL(DWORD ProcessID) //creates InjectDLL function of type BOOL. Accepts a DWORD parameter
{
    if (!ProcessID) // if ProcessID is not provided...
        return false; // terminate program
    
    LPCSTR DLL_PATH = "D:\\Code\\csgo-exploits\\Test DLL\\x64\\Debug\\Test DLL.dll"; //creates variable of type LPCSTR that holds the path to the DLL. LPCSTR is a pointer to a const string
    LPVOID LoadLibAddr, RemoteString; //creates two variables of type LPVOID. LPVOID is a void pointer that has no associated type

    HANDLE Proc = OpenProcess(CREATE_THREAD_ACCESS, FALSE, ProcessID); // creates a new variable of type HANDLE, which creates handle to the process provided by the user and with desired access flags
    if (!Proc) //if handle cannot be established...
    {
        std::cout << "OpenProcess() failed: " << GetLastError() << std::endl; //print to console and display error message
        return false; // terminate program
    }

    LoadLibAddr = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA"); //LoadLibAddr variable = retreives module handle for kernel32.dll and the address of the LoadLibraryA function within it

    RemoteString = (LPVOID)VirtualAllocEx(Proc, NULL, strlen(DLL_PATH) + 1, MEM_COMMIT, PAGE_READWRITE); //RemoteString variable = allocates memory in the target process the strlen size of DLL_PATH pointer
    if (!RemoteString) //if memory cannot be written into the target process...
    {
        std::cout << "Required memory could not be allocated: " << GetLastError() << std::endl; //print to console and display error message
        return false; //terminate program
    }
    
    WriteProcessMemory(Proc, RemoteString, (LPVOID)DLL_PATH, strlen(DLL_PATH) + 1, NULL); //writes the DLL path using the DLL_PATH pointer into the memory space provided by the RemoteString pointer
    if (!WriteProcessMemory) //if DLL path could not be written into process memory...
    {
        std::cout << "Memory could not be written: " << GetLastError() << std::endl; //print to console and display error message
        return false; //terminate program
    }

    CreateRemoteThread(Proc, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibAddr, RemoteString, NULL, NULL); //executes the DLL by executing LoadLibraryA that has a parameter of where the DLL is stored in the local memory space of the process
    if (!RemoteString) //if DLL could not be executed inside the process...
    {
        std::cout << "DLL could not be executed: " << GetLastError() << std::endl; //print to console and display error message
        return false; //terminate program
    }
    
    CloseHandle(Proc); //close handle to target process, stored in Proc
    VirtualFreeEx(Proc, RemoteString, NULL, MEM_RELEASE); // releases allocated memory

    std::cout << "Injection successful!";
    return true; //terminate program
}

BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam) { //creates callback function
    DWORD dwThreadId, dwProcessId; //creates two variables of type DWORD
    HINSTANCE hInstance; //creates variable of type HINSTANCE. This variable will accept a handle to an instance or module
    char String[255]; //creates variable of type char that holds the value 255
    if (!hWnd) // If it is a window
        return TRUE;        
    if (!::IsWindowVisible(hWnd)) // If the window is not visible
        return TRUE;        
    if (!SendMessage(hWnd, WM_GETTEXT, sizeof(String), (LPARAM)String)) // If the window has no title
        return TRUE;        
    hInstance = (HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE);
    dwThreadId = GetWindowThreadProcessId(hWnd, &dwProcessId);
    std::cout << "PID: " << dwProcessId << '\t' << String << '\t' << std::endl;
    return TRUE;
}

int main() {
    if (IsWindowsXPOrGreater()) { // if Windows is of version XP or higher....
        std::cout << "Available Targets:\n" << std::endl; // prints "Available Targets" to console
        EnumWindows(EnumWindowsProc, NULL); // displays list of processes and their process IDs
        std::cout << "\nEnter Process ID" << std::endl; // prints "Enter Process ID" to console
        DWORD PID; //creates new variable called PID of type DWORD
        std::cin >> PID; //prompts user to enter desired PID and place result inside PID variable
        InjectDLL(PID); //executes InjectDLL function, passing the variable PID and what is stored inside
    }
    else {
        std::cout << "Injector not supported by OS. Terminating" << std::endl;
        return 0; //terminate program
    }

    return 0;
}