#include <Windows.h> //DWORD
#include <iostream> //User input/output
#include <string>
#include <psapi.h> //EnumProcessModules
#include <VersionHelpers.h> //For Windows Version
#include <atlstr.h> // CString

#define CREATE_THREAD_ACCESS (PROCESS_CREATE_THREAD | PROCESS_QUERY_INFORMATION | PROCESS_VM_OPERATION | PROCESS_VM_WRITE | PROCESS_VM_READ) // desired access flags for OpenProcess

BOOL InjectDLL(DWORD ProcessID) //creates InjectDLL function of type BOOL. Accepts a DWORD parameter
{
    LPCSTR DLL_PATH = "D:\\Code\\csgo-exploits\\hello-world-x64.dll"; //creates variable of type LPCSTR that holds the path to the DLL. LPCSTR is a pointer to a const string
    LPVOID LoadLibAddr, RemoteString; //creates two variables of type LPVOID. LPVOID is a void pointer that has no associated type

    if (!ProcessID) // if ProcessID is not provided...
        return false; // terminate program

    HANDLE Proc = OpenProcess(CREATE_THREAD_ACCESS, FALSE, ProcessID); // creates a new variable of type HANDLE, which creates handle to the process provided by the user and with desired access flags

    if (!Proc) //if handle cannot be established...
    {
        std::cout << "OpenProcess() failed: " << GetLastError() << std::endl; //print to console and display error message
        return false; // terminate program
    }

    LoadLibAddr = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA"); //LoadLibAddr variable = retreives module handle for kernel32.dll and the address of the LoadLibraryA function within it

    RemoteString = (LPVOID)VirtualAllocEx(Proc, NULL, strlen(DLL_PATH) + 1, MEM_COMMIT, PAGE_READWRITE); //RemoteString variable = allocates memory in the target process the strlen size of DLL_PATH pointer

    if (!RemoteString) //if memory cannot be written into the target process...
    {
        std::cout << "Required memory could not be allocated: " << GetLastError() << std::endl; //print to console and display error message
        return false; //terminate program
    }
    
    WriteProcessMemory(Proc, RemoteString, (LPVOID)DLL_PATH, strlen(DLL_PATH) + 1, NULL); //writes the DLL path using the DLL_PATH pointer into the memory space provided by the RemoteString pointer
    CreateRemoteThread(Proc, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibAddr, RemoteString, NULL, NULL); //executes the DLL by executing LoadLibraryA that has a parameter of where the DLL is stored in the local memory space of the process

    VirtualFreeEx(Proc, RemoteString, NULL, MEM_RELEASE); // releases allocated memory
    CloseHandle(Proc); //close handle to target process, stored in Proc

    std::cout << "Injection successful!";
    return true; //terminate program
}

BOOL CALLBACK EnumWindowsProc(HWND hWnd, LPARAM lParam) {
    DWORD dwThreadId, dwProcessId;
    HINSTANCE hInstance;
    char String[255];
    if (!hWnd)
        return TRUE;        // Not a window
    if (!::IsWindowVisible(hWnd))
        return TRUE;        // Not visible
    if (!SendMessage(hWnd, WM_GETTEXT, sizeof(String), (LPARAM)String))
        return TRUE;        // No window title
    hInstance = (HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE);
    dwThreadId = GetWindowThreadProcessId(hWnd, &dwProcessId);
    std::cout << "PID: " << dwProcessId << '\t' << String << '\t' << std::endl;
    return TRUE;
}

int main() {
    if (IsWindowsXPOrGreater()) { // if Windows is of version XP or higher....
        std::cout << "Available Targets:\n" << std::endl; // prints "Available Targets" to console
        EnumWindows(EnumWindowsProc, NULL); // displays list of processes and their process IDs
        std::cout << "\nEnter Process ID" << std::endl; // prints "Enter Process ID" to console
        DWORD PID; //creates new variable called PID of type DWORD
        std::cin >> PID; //prompts user to enter desired PID and place result inside PID variable
        InjectDLL(PID); //executes InjectDLL function, passing the variable PID and what is stored inside
    }
    else {
        std::cout << "Injector not supported by OS. Terminating" << std::endl;
        return 0; //terminate program
    }

    return 0;
}