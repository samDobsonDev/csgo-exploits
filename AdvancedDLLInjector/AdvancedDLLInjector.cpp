#include <Windows.h>
#include <tlhelp32.h>
#include <iostream>
#include <string>

bool BypassTrustedMode(const HANDLE bypassHandle); //initialises BypassTrustedMode function

int main()
{
    AllocConsole();
    std::cout << "Advanced DLL Injector - created by Sam Dobson\n\n";

    const char* dllPath = "D:\\Code\\csgo-exploits\\hello-world-x86.dll";
    const char* processName = "csgo.exe";

    DWORD processID = 0;

    PROCESSENTRY32 processArray{ 0 }; //creates array
    processArray.dwSize = sizeof(processArray); //sets size of structure

    HANDLE findProcessID = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0); //creates snapshot of all current processes ...
    BOOL processEnum = Process32First(findProcessID, &processArray); //gets first result and places it in the array
    while (processEnum)
    {
        if (strcmp(processName, processArray.szExeFile) == 0) //if processName and the current process being enumerated have the same name...
        {
            processID = processArray.th32ProcessID; //set processID to the ID of the current process being enumerated
            break;
        }
        processEnum = Process32Next(findProcessID, &processArray); //gets next result and places it in the array
    }

    CloseHandle(findProcessID);

    if (processID == 0)
    {
        std::cout << "Process ID could not be found - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "The process ID of target process is: " << (processID) << std::endl;
    }

    HANDLE processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, processID);
    if (!processHandle)
    {
        std::cout << "\nFailed to gain a handle to the process - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nHandle to target process acquired..." << std::endl;
        BypassTrustedMode(processHandle); //execute BypassTrustedMode function, giving the handle as a parameter
    }

    void* memoryAddress = VirtualAllocEx(processHandle, NULL, strlen(dllPath) + 1, MEM_COMMIT, PAGE_READWRITE);
    if (!memoryAddress)
    {
        std::cout << "\nMemory space could not be allocated - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nMemory space allocated..." << std::endl;
    }

    bool memoryWrite = WriteProcessMemory(processHandle, memoryAddress, dllPath, strlen(dllPath) + 1, NULL);
    if (!memoryWrite)
    {
        std::cout << "\nMemory space could not be written to - Error code: " << GetLastError() << std::endl;
        return false;
    }
    else
    {
        std::cout << "\nMemory space written to..." << std::endl;
    }

    HANDLE memoryWriteHandle = CreateRemoteThread(processHandle, NULL, NULL, (LPTHREAD_START_ROUTINE)LoadLibraryA, memoryAddress, NULL, NULL);
    if (!memoryWriteHandle)
    {
        std::cout << "\nDLL could not be injected - Error code: " << GetLastError() << std::endl;
        return false;
    }

    CloseHandle(memoryWriteHandle);
    CloseHandle(processHandle);

    std::cout << "\nInjection successful!\n\n";
    system("pause");
    return 0;
}

bool BypassTrustedMode(const HANDLE bypassHandle) //function that bypasses CS:GO's Trusted Mode. 
// CS changes the first 5 bytes of ntdll/NtOpenFile to a hook to VAC using the asm instruction jmp, to make sure LoadLibrary isn't being used
{
    HMODULE hModule = LoadLibrary("ntdll"); //gets base address of the ntdll.dll module in memory. LoadLibrary loads the specified module

    if (hModule)
    {
        void* pointerNtOpenFile = GetProcAddress(hModule, "NtOpenFile"); //retrieves the memory address of the NtOpenFile function from the ntdll.dll module

        if (pointerNtOpenFile)
        {
            char originalBytes [5]; //creates a new variable that holds an array of 5 chars - 1 char = 1 byte
            memcpy(originalBytes, pointerNtOpenFile, 5); //copies first 5 bytes from the NtOpenFile function and places it in the originalBytes variable
            bool bypassMemoryWrite = WriteProcessMemory(bypassHandle, pointerNtOpenFile, originalBytes, 5, 0); 
            //using the handle we have to CS, we write the original 5 bytes of NtOpenFile back into CS process
            
            if (!bypassMemoryWrite)
            {
                std::cout << "\nFailed to bypass Trusted Mode " << GetLastError() << std::endl;
                return false;
            }
            else
            {
                std::cout << "\nTrusted Mode Bypassed..." << std::endl;
                return true;
            }
        }
    }
}
